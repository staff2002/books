## 一顿晚饭，了解简单工厂

晚上 6:45，熊小猫和兔小白在 ”啃得起“ 吃晚饭。一边吃一边在闲聊。

图：啃得起吃饭

兔小白：和你说个有意思的事情！去年我面试被问到什么是工厂模式。当时的我完全没听过，汗瞬间就下来了。你猜我最后怎么回答的？

熊小猫：不懂就承认嘛，不用死扛。

兔小白：哎，其实我也算如实回答。我说我一直做银行系统开发，对银行模式比较了解，工厂模式不清楚…...

图：回答银行模式的图

熊小猫：哈哈，这不笑掉大牙了！

兔小白：面试官憋住没笑出来，估计大腿都掐紫了。

熊小猫：其实面试官给你挖坑呢，工厂模式有好几种，后面还有更多问题等着问你呢。但谁知道你还没到坑前，就摔了个大跟头！

图：好多关卡，还没到七点就摔躺下了。

兔小白：真是羞愧难当，我一种都不知道。

熊小猫：告诉你一个最简单的----简单工厂。简单到没有资格入选 GOF 的 23 种设计模式。但在日常开发中却非常好用，能够应付很多没那么复杂的场景。别看简单，但也体现了很多设计原则。

兔小白：好啊，以我现在的水平，还是先学会爬再学跑吧！

熊小猫：你倒有自知之明。我今天吃的板烧鸡腿堡，你吃的什么？

兔小白：我吃的牛肉汉堡。怎么？你想尝尝我的？

熊小猫：哈哈，我才不吃你的。注意听，我已经在讲简单工厂了！

咱们俩的汉堡虽然不一样，但都在厨房制作。厨房就是一个汉堡工厂，可以制作各式各样的汉堡。这就是简单工厂模式。

*图：汉堡店生产各种汉堡出来*

兔小白：这个例子我倒是听懂了。但简单工厂能带来什么好处呢？我没想出来。

熊小猫：想一想如果没有 ”啃得起“，你想吃汉堡需要怎么办？

兔小白：我可以去 ”麦当当“ 呀！

熊小猫：一看你就不会做饭！假如没有汉堡店，你就得自己做汉堡。

兔小白：那我宁可不吃，太麻烦了！我得买汉堡坯子、牛肉、生菜、调味酱。自己再动手一步步制作出来。去汉堡店的话，我只需要在收银台下单就搞定了！

图：兔小白去超市采购

熊小猫：哈哈，你已经把工厂模式的好处说出来了！

兔小白：啊？？？？？

熊小猫：自己做汉堡需要关注制作汉堡的原料----对肉、菜、酱都会产生依赖。还要学习制作汉堡的方法。但你的目的是吃汉堡，了解这些制作细节意义不大。而且一不小心还会出错。

于是汉堡店就出现了！它封装了制作汉堡的细节。收银员就是汉堡店对外提供的调用方法。你想要什么汉堡告诉收银员就可以了。现在你只依赖汉堡店，忘了那些肉、菜、酱吧！

图：对比自己做汉堡和汉堡店买汉堡。汉堡店挂着牌子“商业机密”！封装了制作过程。

还有汉堡店经常推出新品。你来店里下单就可以吃到新品了。但如果没有汉堡店，那么所有想吃新汉堡的人都得学习新品制作方法。你要先麻烦，那就别吃。这样是不是一点都不拥抱变化？

兔小白：每个人都学习制作方法，那不就是Ctrl C + Ctrl V嘛！

熊小猫：不错，你已经联想到写代码了！这样做相当于在**复制**代码。程序需要的是**复用****，**并不提倡复制。把制作汉堡的能力封装在汉堡店中，顾客到店直接购买。这是**复用**了汉堡店制作汉堡的能力。我再问问你，你的工作是什么？

我再问问你，你的工作是什么？

兔小白：作为程序员，当然是写代码了！

熊小猫：那你学习什么做汉堡！！？？你是不是违反了单一职责！

兔小白：…… 我这不是平衡工作和生活嘛！

熊小猫：哈哈， 这个理由我接受。不过电脑是无情的工作机器，并不需要平衡。软件设计要尽量符合单一职责。

兔小白：听你这么一说，简单工厂确实带来了很多好处！不过作为程序员，最重要的还是 show me the code！

熊小猫：走，去我家！其实还有很多简单工厂的好处没讲出来呢！咱们直接上代码！



## 商品推荐功能初版代码

饭后，兔小白来到了熊小猫家里，两人继续之前的话题----简单工厂。

熊小猫：我先给你出一道题。咱们公司开发的购物系统要增加一个推荐模块。不同的购物频道推荐的商品不一样，并且推荐的逻辑也有区别。你来写代码实现。对了，推荐算法的实现不用写，示意就可以。推荐的频道目前有手机、电视、笔记本电脑。

图：推荐系统需求示意

兔小白：这还不好办，很快搞定！

```java
public class ProductRecommender {
    public List<String> recommend(String category) {
        List<String> products = new ArrayList<>();

        if ("phone".equals(category)) {
            products.add("huawei mate 60");
            products.add("iphone 14");
            products.add("xiaomi 15");
        } else if ("TV".equals(category)) {
            products.add("TCL T85");
            products.add("sony X75");
            products.add("samsung QA55");
        } else if ("notebook".equals(category)) {
            products.add("Lenovo R7000P");
            products.add("hp 9victus");
            products.add("dell g16");
        } else {
            products.add("huawei mate 60");
            products.add("TCL T85");
            products.add("dell g16");
        }
        return products;
    }

    public static void main(String[] args) {
        ProductRecommender productRecommender = new ProductRecommender();
        List<String> phones = productRecommender.recommend("phone");
        phones.forEach(phone -> System.out.println(phone));
    }
}
```

兔小白：因为是推荐器，所以类名是 recommender。是不是很符合面向对象？代码逻辑很简单，需要推荐哪一类的商品，就会走到相应的分支。如果不是已知的三种品类，就随便推荐几个商品。

熊小猫：代码写的非常直观！不过……除了类名起的像个对象，其实代码和面向对象一点关系也没有。

兔小白：不带这么打击人的！！

熊小猫：哈哈，别生气！你有没有觉得 recommend 方法太长了？

兔小白：逻辑都在这个方法里，确实有点长了。我可以把每种品类的推荐过程封装成方法。

熊小猫：还有谁让你擅自加需求？品类不符合直接报错处理，不要随便推荐商品！

兔小白：没问题，马上改！

```java
public class ProductRecommender {
    public List<String> recommend(String category) throws Exception {
        List<String> products = new ArrayList<>();

        if ("phone".equals(category)) {
            recommendPhone(products);
        } else if ("television".equals(category)) {
            recommendTelevision(products);
        } else if ("notebook".equals(category)) {
            recommendNotebook(products);
        } else {
            throw new Exception();
        }

        return products;
    }

    private void recommendPhone(List<String> products) {
        products.add("huawei mate 60");
        products.add("iphone 14");
        products.add("xiaomi 15");
    }

    private void recommendTelevision(List<String> products) {
        products.add("huawei mate 60");
        products.add("iphone 14");
        products.add("xiaomi 15");
    }

    private void recommendNotebook(List<String> products) {
        products.add("Lenovo R7000P");
        products.add("hp 9victus");
        products.add("dell g16");
    }

    public static void main(String[] args) {
        ProductRecommenderV2 productRecommender = new ProductRecommenderV2();
        try {
            List<String> phones = productRecommender.recommend("phone");
            phones.forEach(phone -> System.out.println(phone));
        } catch (Exception e) {
            System.out.println("您的输入有错误");
        }
    }
}
```

兔小白：这版代码的 ”层次感“ 是不是就出来了。有句话叫**代码即文档**，这不就在说我的代码吗？通过提取方法，并且采用合理的方法命名，代码可读性大大提升。

熊小猫：嗯……确实有进步。不过是不是优秀的代码，一测便知！听好，需求变更来了！

现在需要推荐的频道多了图书频道。你的代码要怎么改？

## 开闭原则和单一职责

兔小白：太容易了，只需加一个 recommendBook方法。然后在 recommend 方法中增加 book 分支处理，调用recommendBook()。

熊小猫：看来昨天学的设计原则你全都忘了！回忆一下开闭原则----**对扩展开放，对修改关闭**。每次增加推荐品类，都要修改 ProductRecommender类，违背了开闭原则。

兔小白：这里我有些糊涂。要加功能，肯定要修改代码，不让修改怎么加功能？

熊小猫：哈哈，这里的修改指修改已经存在的类。实现新功能时，尽量不要修改已经存在的类，而是增加新的类。

兔小白：现在只有推荐类，所有逻辑都在里面。我只能通过改才能做新需求呀！

熊小猫：对呀，就一个对象，你还好意思说非常符合面向对象？思考一下，是不是可以把每个品类推荐的逻辑给封装并提取出来。提醒一下，还记得既要写代码又要做汉堡的你吗？

兔小白：哦，**单一职责**！有点思路了，我先去写代码。

半小时后…...

兔小白：我创建了三个 xxxRecommender 类，只负责自己品类的产品推荐。例如phoneRecommend。

```java
public class PhoneRecommender {
    public List<String> recommend() {
        List<String> products = new ArrayList<>();
        products.add("huawei mate 60");
        products.add("iphone 14");
        products.add("xiaomi 15");
        return products;
    }
}
```

推荐逻辑已经从 ProductRecommender 移到每个 xxxRecommender 中。

在 ProductRecommender 中实例化这三种推荐器。根据输入品类选择不同的推荐器进行推荐。

```java
public class ProductRecommenderV3 {
    private PhoneRecommender phoneRecommender = new PhoneRecommender();
    private TelevisionRecommender televisionRecommender = new TelevisionRecommender();
    private NotebookRecommender notebookRecommender = new NotebookRecommender();

    public List<String> recommend(String category) throws Exception {
        if ("phone".equals(category)) {
            return phoneRecommender.recommend();
        } else if ("television".equals(category)) {
            return televisionRecommender.recommend();
        } else if ("notebook".equals(category)) {
            return notebookRecommender.recommend();
        } else {
            throw new Exception();
        }
    }
}
```

兔小白：这下加书籍的品类推荐就太简单了！只需要增加一个 BookRecommender，然后在 ProductRecommender 中调用它的 recommend 方法。

 roductRecommender 仅有少量改动，主要的推荐逻辑都在新增加的 BookRecommender 中！

熊小猫：不错，这版代码已经有点样子了。满足了**开闭原则、单一职责**。但还有很大优化空间。回忆一下做汉堡的例子里，汉堡是哪里来的？你的代码还缺点啥？

兔小白：哦！还缺汉堡工厂！不对….还缺推荐器工厂！

## 推荐器工厂实现依赖反转

熊小猫：熊小猫：没错！下面这些实例化 Recommender 对象的职责，应该交给工厂类。ProductRecommend 通过工厂获取 Recommender 。这里的Recommender就是各式各样的汉堡包。

```java
private PhoneRecommender phoneRecommender = new PhoneRecommender();
private TelevisionRecommender televisionRecommender = new TelevisionRecommender();
private NotebookRecommender notebookRecommender = new NotebookRecommender();
```

熊小猫：写了这么多版代码终于见到了工厂！为了避免返工，我再提醒你可以使用多态特性进行优化。这几个xxxRecommender 的行为是不是一样？甚至名字都差不多！怎么修改也就不言而喻了。

兔小白：我大概懂你的意思了，改完看看是不是你想要的！

十分钟后…...

兔小白：代码写完了！多亏你提示我考虑多态，否则工厂类我还真写不出来。工厂需要返回多种
Recommender，好在有多态，问题迎刃而解！

首先，增加了recommender接口。

```java
public interface Recommender {
    List<String> recommend();
}
```

各种品类的 xxxRecommend 类实现该接口，例如PhoneRecommender。

```java
public class PhoneRecommender implements Recommender{
    public List<String> recommend() {
        List<String> products = new ArrayList<>();
        products.add("huawei mate 60");
        products.add("iphone 14");
        products.add("xiaomi 15");
        return products;
    }
}
```
下面重头戏来了，工厂类千呼万唤始出来----RecommenderFactory 类。他负责实例化所需的 xxxRecommender 对象。这里用了多态的特性，可以返回任意实现了 Recommender 接口的对象。

```java
public class RecommenderFactory {
    public Recommender createRecommender(String category) throws Exception {
        switch (category){
            case "phone":
                return new PhoneRecommender();
            case"television":
                return new TelevisionRecommender();
            case "notebook":
                return new NotebookRecommender();
            default:
                throw new Exception();
        }
    }
}
```
实例化 Recommender 对象的职责移走后。ProductRecommender的职责就只剩推荐商品。进一步强化了单一职责。

```java
public class ProductRecommenderV3 {
   private RecommenderFactory recommenderFactory = new RecommenderFactory();
    public List<String> recommend(String category) throws Exception {
        Recommender recommend = recommenderFactory.createRecommender(category);
        return recommend.recommend();
    }
} 
```

ProductRecommender 不再依赖具体的几个 xxxRecommender 类，而是依赖 Recommender 接口。符合**依赖反转原则**，也就是我们常说的**面向接口编程**。

这样做的好处是，一旦要增加新的品类推荐，只需要增加新的 xxxRecommender 类，工厂类增加创建的条件分支。而 ProductRecommender 不需要修任何代码！完全符合**开闭原则！单一职责原则！依赖反转**！满足….

熊小猫：停！停！停！现在时间不早了，别喊这么大声！

兔小白：不好意思，自己的代码被不断打磨，雕琢的越来越精致，我有些兴奋！而且我没想到一个最简单的设计模式，居然带来了这么多设计的 “好味道”。

熊小猫：虽然你的学习热情有点吓人，但是值得肯定！学习编程需要不疯魔不成活的精神。永远都要有追求技术卓越之心！

兔小白：努力没有白费。终于写出了完美的程序！

熊小猫：嗯…...真的那么完美吗？ 看下面的代码结构图。ProductRecommender 依赖 RecommenderFactory 。RecommenderFactory 是一个具体的类，不是接口。是不是违反了依赖反转原则？

兔小白：你这么一说…...确实存在这个问题。我马上看看怎么修改！

熊小猫：哈哈，说你胖还就喘上了！简单工厂就是如此，虽然不完美，但却很实用。明天我再教你**工厂方法模式**来解决这个问题。工厂方法可是根正苗红的23 种设计模式之一！今天太晚了，先回家休息吧。对了，这份简单工厂的类图你拿上。

类图

兔小白：好嘞，正好在回家路上看。明晚咱们继续！

图：回家的末班车上，兔小白在研究类图。配上震撼人心的金句。




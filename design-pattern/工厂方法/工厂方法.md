## 打造工厂标准——工厂再抽象

第二天晚上，兔小白又来到了熊小猫家里学习设计模式。

熊小猫：昨天的问题想明白了吗？ 简单工厂里的 ProductRecommender 依赖了 RecommenderFactory 的具体实现。从而违反了依赖反转原则。

兔小白：昨晚回家路上我一直在研究简单工厂的类图，已经发现问题所在了！你看这个工厂类没有接口，所以ProductRecommender 类直接依赖了 RecommenderFactory。改造起来也简单，先声明 IRecommenderFactory 接口，再让RecommenderFactory 实现该接口。那么 ProductRecommender 就可以依赖 Factory 接口，从而实现了依赖反转。

图：纸质类图，没有接口，改造成有接口的。

熊小猫：这么努力，路上还在研究！当初把你招聘进来，我没有看错！长江后浪推前浪，今天看来不需要我讲啦！

兔小白：你又取笑我！今天可是要讲工厂方法模式。你别撂挑子不干！

熊小猫：我之所以这么说，就是因为你这版代码已经是工厂方法模式了！

兔小白：什么？我自己都不知道！而且加一个工厂的接口，我没看出来有什么好处。你不是把 “不要为了设计而设计” 挂在嘴边吗？你可别着急退休，还得你给我讲讲。

熊小猫：哈哈，和你开玩笑！确实很多时候，即使你没有学过设计模式，但是熟知开闭原则、单一职责、依赖反转等设计思想，就会不知不觉地使用了某种设计模式。

兔小白：嗨，我还谈不上熟知设计思想，都是被你一步步引导到这的。还是老师你厉害啊！

熊小猫：停！停！不用这么恭维我！！其实这是一种成熟的编程方式。先直观的写完代码，再通过重构不断完善代码。重构也是非常非常重要的概念，不过咱们暂且不说，先把设计模式学好。

我们回到推荐器的代码上来。你的这一版代码是工厂方法模式中的一种实现方式：参数化工厂方法。工厂方法通过参数，可以选择创建多种产品。

这种工厂方法模式和简单工厂相比，只是多了工厂的接口。从而让 ProductRecommender 摆脱了对具体的RecommenderFactory 类依赖，而是依赖 IRecommenderFactory 接口。

兔小白：问题就出在这。在我看来只是多了一个接口，没看到好处在哪里。

熊小猫：**接口定义了行为，抽象出工厂的接口，相当于打造了工厂的标准。**依赖接口，也就是只认标准，不认实现。这样就可以任意替换接口的实现。打个比方，假如 RecommenderFactory 使用的是名为 “土星” 的推荐引擎来创建 xxxRecommender。但某一天市场上出现了更为先进的 “火星” 推荐引擎。我想让 xxxRecommender 用上 “火星” 推荐引擎，你说怎么办？

兔小白：土星、火星？你要上天吗？？多简单的事情， 我把 RecommenderFactory 改成用 “火星“ 推荐引擎创建 xxxRecommender 不就可以了？

熊小猫：哈哈，给你个坑，你真往里面跳啊！开闭原则又忘了？现在我们可是有 IRecommenderFactory 接口，

只需要创建新的 RecommenderWithMarsFactory 实现该接口。添加新的类来实现新功能，符合开闭原则。

同时我们把之前的 RecommenderFactory 重构一下，重命名为 RecommenderWithMercuryFactory。这样我们就有了两个 IRecommenderFactory的实现。你想用哪个就用哪个，随意替换，随心所欲！

兔小白：那我斗胆总结下，如果工厂类有被其他实现替掉的可能性，那么可以考虑工厂方法模式。

熊小猫：没错，设计模式的每一次变化或者说每一层抽象，都是为了应对变化，使得的软件组件可复用。但不要忘了可复用的同时带来的是代码的复杂化。成本和收益要考虑清楚，这也是简单工厂同样很流行的原因。如果对未来的变化很难预测，那么建议先使用简单工厂。毕竟从简单工厂重构成工厂方法也不难。

兔小白：我一听到 ”权衡“，就知道又是不可言说的知识。俗话说的好  ”一听就会，一做就废“。

图，听到时候，懂了懂了，一自己开发，什么玩意！

熊小猫：哈哈，想要活学活用，一定需要大量实践，不断归纳总结。我能告诉你的只是原则和建议，剩下的需要你在实践中自己去悟。

## 厨房也可以分工

熊小猫：不过先别着急去实践。工厂方法还没讲完呢。刚才例子中的两个工厂都负责了所有产品的实例化。工厂模式还有别的用法。每个工厂也可以只负责部分产品的生产。极端情况，一个工厂仅负责生产一个产品。

就像汉堡店的厨房也可以不只一个，或者厨房内部划分区域。1 号厨房加工煎肉类汉堡（牛排、板烧鸡腿），2 号厨房加工油炸类汉堡（鳕鱼、炸鸡）。这样做有什么好处呢？

1. 多个后厨将制作汉堡的过程做了分类。那么每个后厨只需要采购自己生产的汉堡品类所需工具即可，例如1 号后厨使用铁板煎烤，不需要采购油炸锅。
2. 如果有新品汉堡上市，例如推出了煎猪排堡，那么只有1 号后厨需要了解制作方法，并做出相应改造。 2号厨房完全不关心这个事情。

甚至极端情况，可以让一个后厨只生产一种汉堡。这种情况下，产品变化带来的影响最小，但是运转成本最高。所以一般在现实世界不会这样做。但在软件世界中，这是很可能出现的设计方式。

图：不同汉堡后厨生产的汉堡品类有区别。

兔小白：这样说来，如果推出新品——北京烤鸭汉堡，那就需要新增一个 3 号厨房制作烧烤类汉堡。

熊小猫：没错，这样符合开闭原则。如果改造1号或者2号厨房，一旦改坏了，今天生意就别做了。

图：改坏了冒烟，今天停业

兔小白：工厂方法，妙哉啊！等我写不动代码了，就用工厂方法去开个汉堡店。

熊小猫：等你学完23种设计模式再去开店，会经营的更棒！

兔小白：你是不是又在调侃我？

熊小猫：我可不是瞎说。世间万物底层的思想是相通的。设计模式本来就来自于现实世界。设计模式既是浓缩的 ”套路“，也是精选的 ”门道“。

兔小白：我想到一个问题！之前只有一个厨房时，收银员下单给这个厨房就可以了。现在这么多后厨，应该如何下单呢？

熊小猫：好问题啊！引入更为复杂的设计模式，肯定会带来更高的复杂度。这个时候，收银员就得动点脑子了。他需要知道汉堡和工厂的映射关系。也就是说收银员多了一些工作，他需要将指定汉堡的订单下给正确的厨房。不过好在现如今是信息化时代，点菜系统都帮他做啦！

## 需求膨胀？工厂也可以膨胀！

熊小猫：我们再回到推荐器程序代码。我来看看你有没有理解刚才讲的内容。需求变更来了！手机和电视用 ”水星“ 推荐引擎，笔记本电脑用 ”火星“ 推荐引擎。未来新的品类可能要用 ”木星“ 推荐引擎。你想想代码要怎样改？

兔小白：这不就是汉堡店的 1、2、3 号厨房嘛！写 2 个 IRecommenderFactory 的实现就可以了。对了，还得有个类似收银员的类，来做根据汉堡匹配厨房的工作。

20分钟后。

兔小白：IRecommenderFactory 的接口定义没有任何改变。我根据需求修改了两个实现

```java
public class RecommenderWithMercuryFactory implements IRecommenderFactory{
    public Recommender createRecommender(String category) throws Exception {
        switch (category){
            case "phone":
                return new PhoneRecommender();
            case"television":
                return new TelevisionRecommender();
            default:
                throw new Exception();
        }
    }
}
```

```java
public class RecommenderWithMarsFactory implements IRecommenderFactory{
    public Recommender createRecommender(String category) throws Exception {
        switch (category){
            case "notebook":
                return new NotebookRecommender();
            default:
                throw new Exception();
        }
    }
}
```

之前的 ProductRecommender 代码中直接实例化 RecommenderFactory。但现在它并不知道应该实例化哪个 RecommenderFactory。因此我增加了 RecommenderFactorySelector 类用来映射category 和 RecommenderFactory 的关系。其实做的就是根据汉堡匹配厨房的事情。

```java
public class RecommenderFactorySelector {
    public IRecommenderFactory createFactory(String category) throws Exception {
        switch (category){
            case "phone":
            case"television":
                return new RecommenderWithMercuryFactory();
            case "notebook":
                return new RecommenderWithMarsFactory();
            default:
                throw new Exception();
        }
    }
}
```

ProductRecommender 中实例化RecommenderFactorySelector，用它来创建工厂。

```java
public class ProductRecommenderV2 {
   private RecommenderWithMercuryFactory recommenderWithMercuryFactory = new RecommenderWithMercuryFactory();
    RecommenderFactorySelector recommenderFactorySelector = new RecommenderFactorySelector();

    public List<String> recommend(String category) throws Exception {
        IRecommenderFactory recommenderFactory = recommenderFactorySelector.createFactory(category);
        Recommender recommend = recommenderFactory.createRecommender(category);
        return recommend.recommend();
    }
}
```

改造后，甭管你水星、火星，还是金星、木星！工厂类都可以做到只增不改！如果产品经理的需求来个宇宙大爆炸，那我就还他一个 factory 大爆炸！

图：各种需求进各种工厂

熊小猫：哈哈，好一个 factory 大爆炸！倒是很形象的描述了工厂方法的特征！最后我再考考你，如此改造后带了了什么好处，又产生了什么负面影响？

兔小白：由于调用方依赖工厂接口，当需求触及工厂的变化时，不再用修改工厂，而是扩展工厂的实现。这样做符合开闭原则，工厂的职责也更为单一，从而增加了代码的灵活度。

不过又引入了 RecommenderFactorySelector 类来选择合适的 RecommenderFactory，增加了代码的复杂度。

熊小猫：没错！代码的复杂度被提高了。你再想一想，所谓的 RecommenderFactorySelector 不就是工厂的工厂吗？

## 工厂的工厂的工厂？抽象要适度

兔小白：可不是嘛，我写代码的时候就有这个疑问。为了避免歧义，我特意用了 selector 后缀命名。

熊小猫：工厂的工厂听起来有些奇怪，但其实符合真实世界。汉堡店的后厨也是由建筑队建造的嘛！如果工厂的工厂也需要灵活性，那么可以有工厂的工厂的工厂…...

图：递归工厂。。。。。

兔小白：我读书少，你别骗我！真的有这么设计软件的吗？

熊小猫：哈哈，你放心，我不敢说没有，但大部分情况是绝不会这么设计。还记得你曾说过一句话 “代码即文档”。如果写出工厂的工厂的工厂这种代码，相信两个月后，作者自己都读不懂了。我们确实需要灵活的、拥抱变化的代码，但记住要适度！

兔小白：“适度”…...又是一个不可言说的知识。好在学习完工厂模式，我可以去实践了！

熊小猫：哼哼！纠正一下，仅仅学完了工厂方法模式。明晚继续学习抽象工厂！

兔小白：不行，我脑子已经不够用啦！

图：口吐白沫。。。。。